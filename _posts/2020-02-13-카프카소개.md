# 소개(목적, 적합한 용도)

# 해결하고자한 과제

- 프로듀서와 컨슈머의 분리
- 메시징 시스템과 같이 영구 메시지 데이터를 연러 컨슈머에 허용
- 높은 처리량을 위한 메시지 최적화
- 데이터가 증가함에 따라 스케일 아웃이 가능한 시스템
- 큰 데이터를 처리할 수 있어야함
- 메세지 포맷이 가변적이면 안되고, 프로토콜이 여러 개가 있었는데 하나로 묶을 수 있어야한다.

# 카프카가 필요한 프로젝트 예시

- 메트릭 모니터링용 데이터 시스템 : 서비스에서 발생하는 미터링(사용량, 응답 시간, 에러 카운트) 정도를 저장할 시계열 데이터 처리 시스템
- 로그 모니터링용 데이터 시스템 : 로그를 저장하고 이것을 기반으로 실시간 또는 배치로 분석할 수 있도록 데이터를 저장하는 시스템
- 서비스에서 사용하는 컨텐츠와 고객 정보를 저장하는 시스템 : OLTP(Online Transaction Process) 쿼리를 실행
- 추천이나 장바구니 처럼 트랜잭션 처리는 필요없으나 실시간으로 처리해줘야하는 내용을 저장하는 키/값 저장소.
- 서비스에서 발생하는 데이터를 모아 일간,주간,월간,연간 통계가 필요한 시스템
- 빅데이터를 저장/처리하기 위한 시스템

## 전사 데이터 파이프라인으로 동작하는 카프카로 얻는 이득

- 기존 데이터 스토어(DB)뿐만 아니라 새로운 데이터 스토어(검색엔진, DB)가 생겨도 카프카가 제공하는 표준 포맷으로 연결되어 있어서 데이터를 주고 받는데 부담이 없다.
- 신뢰성 높은 데이터
- 카프카에 데이터만 넣고 빼면 되기 때문에 모듈화가 더 쉬움

# 카프카의 동작 방식과 원리

기본적으로 메시징 서버로 동작한다.

메시지라고 불리는 데이터를 보내는 측(publisher, producer)이 토픽이라는 각각의 메시지 저장소에 메시지를 저장하면, 가져가는 측(subscriber, consumer)이 원하는 토픽에서 데이터를 가져가게 되어있다. (pub/sub model)

## 카프카의 Pub/Sub 모델의 장점과 단점

- 직접 통신하면 속도에서 장점이 있지만, 통신하는 상대의 상태를 체크해야하는 등의 문제가 있어 안정성이 떨어진다.
- 카프카로 연결되기 때문에 확장성이 용이하다.
- 교환기 룰에 의해서 데이터가 수신처의 큐에 정확하게 전달되므로 유실되지 않는다. 단, 정확하게 전달되었는지를 확인하려면 코드가 좀 더 복잡해진다.

# 기존 메세지큐와의 차이점

- 멀티 프로듀서, 멀티 컨슈머
- 디스크에 메시지 저장 → 컨슈머가 읽어가면 바로 지워버리는 것이 아니라 보관 주기 동안 디스크에 메시지를 저장해둔다. 이로 인해 백프레셔등 장애 내성을 갖게 된다.
- 높은 확장성 → 3대의 브로커부터 수십대로 확장 가능
- 높은 성능 → 내부적으로 성능에 좋은 기법들 사용

## 카프카 관리를 위한 주키퍼

카프카 같은 분산 애플리케이션을 관리하기 위한 코디네이션 애플리케이션.

→ 카프카를 원활하게 이용하려면 주키퍼에 대한 지식이 풍부해야함.

분산 애플리케이션의 정보를 중앙 집중 관리, 그룹 관리, 동기화등의 기능을 함.

주키퍼 서버들이 이미 클러스터로 이루고 있어야 하고, 그 클러스터를 서버로 봤을 때, 여러 카프카가 클라이언트로써 붙어있는 구조다.

그러면 여러 클라이언트(ex 카프카)들이 서버와 커넥션을 맺고 상태 정보를 주고 받게 된다.

상태정보는 znode(지노드)라는 곳에 key-value형태로 저장되고 znode에 저장된 것을 이용해서 분산된 애플리케이션들은 서로의 데이터를 주고 받는 구조다.

여기서 znode는 주키퍼에서 데이터를 저장하기 위해 사용하는 공간으로 그냥 디렉토리 정도로 생각하면 된다.

# Topics and Logs