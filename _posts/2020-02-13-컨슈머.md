# 컨슈머

## 올드컨슈머 vs 뉴컨슈머

주키퍼를 사용하는 건 올드컨슈머 안 쓰는 건 뉴컨슈머, 주키퍼 지노드에 오프셋을 저장하는 건 이제 사라질 예정(올드컨슈머)

- bootstrap.servers : 카프카 클러스터에 처음 연결하기 위한 호스트와 포트 정보들
- fetch.min.bytes : 한번에 가져올 수 있는 최소 데이터 사이즈, 만약 지정한 사이즈보다 작은 경우, 요청에 응답하지 않고 데이터가 누적되기를 기다림.
- [group.id](http://group.id) : 컨슈머가 속한 그룹을 식별하는 식별자 (그룹아이디는 매우 중요하다)
- enable.auto.commit : 백그라운드로 주기적으로 오프셋을 커밋한다.
- auto.offset.reset : 카프카의 초기 오프셋이 없거나 현재 오프셋이 더 이상 존재하지 않는 경우(삭제된 경우)에 다음 옵션으로 리셋한다.
    - earliest : 가장 초기의 오프셋값으로 설정
    - latest : 가장 마지막의 오프셋값으로 설정
    - none : 이전 오프셋 값을 찾지 못하면 에러 처리
- fetch.max.bytes : 한번에 가져올 수 있는 최대 데이터 사이즈
- [request.timeout.ms](http://request.timeout.ms) : 요청에 응답을 기다리는 최대 시간
- [session.timeout.ms](http://session.timeout.ms) : 컨슈머와 브로커사이의 세션 타임아웃 시간, 컨슈머가 살아있는 것으로 판단하는 시간(기본값 10초). 만약 컨슈머가 그룹 코디네이터에게 heartbeat을 보내지 않고 session.timeout.ms이 지나면 해당 컨슈머는 장애가 있는 것으로 판단하고 컨슈머 그룹은 리밸런스(rebalance)를 시도한다. 얼마나 오래 컨슈머가 있을 수 있는지 설정한다. heartbeat.interval.ms와 밀접한 관련이 있고 session.timeout.ms를 기본 값보다 낮게 설정하면 실패를 빨리 감지할 수 있지만 가비지 컬렉션이나 poll 루프를 완료하는 시간이 길어지게 되면 원하지 않게 리밸런스가 일어날 수 있다. 반대로하면 오류를 감지하는데 시간이 오래걸린다.
- [heartbeat.interval.ms](http://heartbeat.interval.ms) : 그룹 코디네이터에게 얼마나 자주 poll()메서드로 하트비트를 보낼 것인지 조정한다. session.timeout.ms값보다 낮아야 하며 보통 1/3로 설정한다(기본값 3초)
- max.poll.records : 단일 호출 poll()에 대한 최대 레코드 수를 조정한다. 이것으로 폴링 루프에서 데이터양을 조절할 수 있다.
- [max.poll.intervals.ms](http://max.poll.intervals.ms) : 컨슈머가 살아있는 체크하기 위해 주기적으로 보내는데, 컨슈머가 계속해서 하트비트만 보내고 실제로 메시지를 가져가지 않는 경우가 있을 수 있다. 이 경우 무한정 컨슈머가 파티션을 점유할 수 없도록 주기적으로 poll을 호출하지 않으면 장애라고 판단하고 컨슈머 그룹에서 제외한 후 다른 컨슈머가 해당 파티션에서 메시지를 가져갈 수 있게 한다.
- [auto.commit.interval.ms](http://auto.commit.interval.ms) : 주기적으로 오프셋을 커핏하는 시간
- [fetch.max.wait.ms](http://fetch.max.wait.ms) : fetch.min.bytes에 의해 설정된 데이터보다 적은 경우 요청에 응답을 기다리는 최대 시간

컨슈머를 실행할 때는 항상 컨슈머그룹이 있어야한다.

자바, 파이썬 코드

파티션 소유권이 변경되는 것을 리밸런스라함.

## 컨슈머 그룹

그룹내에 컨슈머를 확장해도 다 소비를 못한다면 어떨까? 컨슈머를 더 추가하면 될까? 아니다.

토픽의 파티션에는 하나의 컨슈머만 연결할 수 있기 때문에 추가해도 소용없다.

고로 파티션도 늘리고 컨슈머도 늘리는 방법을 택해야한다.

컨슈머 그룹마다 오프셋정보를 따로 관리해서 지난 메시지에 대한 저장하는 카프카에서 데이터를 뽑아갈 수 있어 유용하다.

## 커밋과 오프셋